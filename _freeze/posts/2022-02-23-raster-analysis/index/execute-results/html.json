{
  "hash": "6052737c5e3547f0259b7ad57cdbd6e8",
  "result": {
    "markdown": "---\ntitle: Basic Raster Analysis with R\nauthor: 'Mitch Rudge'\ndate: '2022-02-24'\nimage: images/layer_output.PNG\nslug: []\ncategories:\n  - spatial\n  - R\n  - terra\ntags: []\nTags: []\nCategories: []\nDisableComments: no\n---\n\n\n**Presented by Mitch Rudge**\\\nPhD Candidate, UQ Sustainable Minerals Institute\\\nTwitter: [![Twitter URL](https://img.shields.io/twitter/url/https/twitter.com/bukotsunikki.svg?style=social&label=Follow%20%2540mitchrudge)](https://twitter.com/mitchrudge)\n\n### This is post is associated with a workshop that was held on the 24th Feb 2022\n\n**Workshop description** Mitch walked through the basics of raster analysis using R. In particular, he focused on the relatively new [Terra](https://github.com/rspatial/terra) package, which is set to replace the extremely popular [Raster](https://github.com/rspatial/raster) package. A basic understanding of R will help, but the workshop will be aimed at beginners with no prior knowledge.\n\n## What we will cover:\n\n1.  Raster and vector basics\n2.  Introducing the Terra package\n3.  Creating, Importing and exporting rasters\n4.  Dealing with coordinate reference systems\n5.  Naming and sub-setting SpatRaster layers\n6.  Raster summaries\n7.  Raster data manipulation\n8.  Compatibility between Raster and Terra\n9.  Options to allow the processing of large files\n10. A real world example with drone data\n11. A fun new package called Layer\n\nYou will need installations of R, RStudio and Terra.\n\n## 1. Raster and vector basics\n\n**Rasters** divide areas into a grid of rectangles of equal size. Each rectangle holds one or more value for a variable of interest.\n\n**Vectors** consist of a series of coordinates that make points, lines or polygons.\n\n![Raster vs vector credit: http://gsp.humboldt.edu/](http://gsp.humboldt.edu/olm/Lessons/GIS/08%20Rasters/Images/convertingdatamodels2.png) http://gsp.humboldt.edu/\n\n## 2. Introducing the Terra package\n\n<img src=\"https://raw.githubusercontent.com/rspatial/terra/master/man/figures/logo.png\" width=\"250\"/>\n\nTerra is set to replace the extremely popular Raster package. It is written by the same group of developers at [r spatial](https://github.com/rspatial), led by Robert Hijmans. This means that Terra is compatible with Raster - with some serious advantages.\n\n**Advantages** of Terra over Raster. It's faster - unlike `Raster`, `Terra` is mostly written in C++, making it much faster for many operations.\n\nIt's simpler - `Terra` does away with the complex data structure of `Raster` like `RasterLayer`, `RasterStack` and `RasterBrick`. We will go into this later.\n\nFor now, lets install and load Terra.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"terra\")\nlibrary(terra)\n```\n:::\n\n\n## 3. Creating, Importing and exporting rasters\n\nThe following examples are largely based on examples from the official [manual](https://cran.r-project.org/web/packages/terra/index.html)\n\nThe `rast()` function is used to create and import `SpatRasters`.\n\nTo create a SpatRaster from scratch:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rast(nrows=108, ncols=108, xmin=0, xmax=10, ymin = 0, ymax = 10)\nvalues(x) <- 1:ncell(x)\n```\n:::\n\n\nAnd, probably more useful, to import a raster from a file:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- system.file(\"ex/meuse.tif\", package=\"terra\") #example data within terra\nr <- rast(f)\n```\n:::\n\n\nBut instead of `system.file()` (which is looking inside the `terra` package), point directly to a raster file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(r)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot-1.png){width=672}\n:::\n:::\n\n\nTo write a `SpatRaster` to file, we can use the the `writeRaster` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- writeRaster(r, \"output.tif\", overwrite=TRUE)\nx\n```\n:::\n\n\n## 4. Dealing with coordinate reference systems\n\nGetting the coordinate reference systems correct is a very important, and sometimes tricky, aspect of geospatial analysis.\n\nThere are two main classes of coordinate reference systems, have a look [here](https://rspatial.org/terra/spatial/6-crs.html) for a pretty good.\n\nAngular coordinate reference systems - these represent the vertical and horizontal angles between the point on the surface and the center of the earth (see figure).\n\n![](https://rspatial.org/terra/_images/sphere.png) Image reference: https://rspatial.org/terra/\n\nTo get location using an angular CRS, we require a pair of coordinates and a reference datum; a model of the shape of the earth. WGS84 is probably the most widely used global datum, where GDA94 / 2020 are commonly used Australian datums.\n\nProjected coordinate reference system - here, angular coordinates have been converted to a Cartesian system, making it is easier to make maps and calculate area etc. These require a projection, a datum and a set of parameters. Projections include Mercator, UTM and Lambert.\n\n**Defining a CRS in Terra**\n\nTerra recommends using the EPSG database, as PROJ.4 is no longer fully supported.\n\nTo look up an EPSG code, go to https://epsg.org/ and find your CRS.\n\nWhen you know the EPSG code associated with your data, you can assign it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs(x) <- \"EPSG:27561\" \n```\n:::\n\n\nBe careful, this defines the CRS but doesn't change the underlying data. It is not generally recommended that you project raster data because it results in a loss of precision.\n\n## 5. Naming and subsetting SpatRaster layers\n\nNaming the layers of a SpatRaster is pretty straightforward, using the `names()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns <- rast(system.file(\"ex/logo.tif\", package=\"terra\"))\nnames(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"red\"   \"green\" \"blue\" \n```\n:::\n\n```{.r .cell-code}\nnames(s) <- c(\"a\", \"b\", \"c\")\nnames(s)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"c\"\n```\n:::\n:::\n\n\nSub-setting the layers of a `SpatRaster` is also a pretty simple operation.\n\nYou can either use square bracket notation `[]`, the `subset()` function, or `$` notation.\n\nFrom the [manual](https://cran.r-project.org/web/packages/terra/terra.pdf), here is an example using the R logo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset(s, 2:3) #will select band 2 and 3\n#because we changed the names from red, green, blue to a, b c. \ns[[c(\"a\", \"b\")]] #will also select band 2 and 3\ns$a #will select the a (red) band\n```\n:::\n\n\nNote that unlike with Raster, there is no need for different classes like Raster stacks/layers/bricks.\n\n## 6. Raster summaries\n\nNow that we know how to import a Raster, define its CRS, and select the bands we are interested in, its a good time to start investigating its values.\n\nThe `global()` function can be used to extract values like the average, mean and max cell values. Using the elevation data we imported earlier, we could work out the highest cell on the map with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmax_h <- global(r, \"max\", na.rm=TRUE)\nmax_h\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      max\ntest 1736\n```\n:::\n:::\n\n\nThe humble histogram is another useful tool when getting a handle on raster data. Terra allows you to create a frequency distribution histogram with `hist()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(r)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/hist-1.png){width=672}\n:::\n:::\n\n\nOr if a boxplot is more your style, you can use `boxplot()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxplot(r)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/boxplot-1.png){width=672}\n:::\n:::\n\n\n## 7. Raster data manipulation\n\nThere are a huge number of functions within Terra for data manipulation, but here are a few that might be useful. \\### Extend and trim Often, we will find a lot of white space consisting of NA's around our Raster. To remove this, we can use the `trim()` function. Conversely, to add white space to a raster (say, to match the extent of another Raster), we can run the `extend()` function.\n\nTo demonstrate this functionality, we will first add a lot of white space to our elevation raster using `extend`, before removing it with `trim`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nextended <- extend(r, 50)\ntrimmed <- trim(extended)\n```\n:::\n\n\n### Aggregate and Resample\n\nThese are used to change the resolution of a `SpatRaster`.\n\nAggregate creates a new `SpatRaster` with a lower resolution. Users need to provide the factor by which the raster will be reduced.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nagg <- aggregate(r, fact = 5, fun = 'mean')\nplot(agg)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/aggregate-1.png){width=672}\n:::\n:::\n\n\nYou can see that the resolution has been reduced, by a factor of five in this case.\n\nIn reality, we will often need to combine rasters from different sources that have different origins and resolutions; this will require us to match the resolution, the origin and the extent. For this, the resample function is the way to go. To demonstrate this, we can first change the origin of the raster we just aggregated.\n\n\n::: {.cell}\n\n```{.r .cell-code}\norigin(agg) <- c(10.5, 10.5)\n```\n:::\n\n\nThen we can resample the original raster, `r`, using the new `agg` raster with different resolution and origin.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrsm <- resample(r, agg, method= 'bilinear')\n```\n:::\n\n\n### Crop\n\nCropping is one of the most widely used operations when working with Raster data. To demonstrate a simple crop, we will need to use a `SpatVector`: the other major data class used by Terra.\n\nOn the data set we have been working on, we will first use the `spatSample()` function, another handy tool.\n\nHere, we will randomly generate one point on the elevation raster.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamp <- spatSample(r, 1, as.points=TRUE, na.rm=TRUE)\n```\n:::\n\n\nNow we can make a buffer centered on this point using the `buffer()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuf <- buffer(samp, width = 200)\nplot(r)\nplot(samp, add=TRUE)\nplot(buf, add=TRUE)\n```\n:::\n\n\n![](images/crop_example1.PNG)\n\nNow we can crop the elevation raster to the buffered area.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncropped <- crop(r, buf)\nplot(cropped)\n```\n:::\n\n\n![](images/crop_example_2.PNG)\n\n### Mask\n\nNotice that the buffer was a circle, but the cropped area is square. Why? Because the crop command uses the extent of the object which is always a rectangle. If you wanted to maintain the shape of the buffer, you will want to use `mask()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmask <- mask(r, buf)\nmask <- trim(mask) #we can trim down all the NA values using the trim function\nplot(mask)\n```\n:::\n\n\n![](images/maskandtrim.PNG)\n\n### Stretch\n\nAnother task is to stretch values to a given range. For example, classification can require data that is normalised to 8bit (0-255). This can be handy if you want to normalise rasters on different scales, such as elevation in m AGL and reflectance in DN.\n\nIn terra, this is as easy as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr <- stretch(r) #defaults to 0-255\nglobal(str, \"range\", na.rm=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     range max\ntest     0 255\n```\n:::\n:::\n\n\n### Focal\n\nThe `focal()` function can be used to clean and smooth rasters. `Focal()` uses a moving window with size `w` and a function to average neighboring cells. Lets do that with the elevation dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- focal(r, w=5, fun=\"mean\")\nplot(f)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n## 8. Compatibility between Raster and Terra\n\nIf you have grow acustomed to using `Raster`, don't worry, it is not difficult switch between Raster classes (RasterLayer, RasterStack etc) and SpatRaster using the `rast()` function.\n\nHere is an example.\n\nFirst install the Raster packages, which is available on CRAN.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"raster\")\nlibrary(raster)\n```\n:::\n\n\nNow, using the sample data loaded into Raster, we can create a Raster stack of the r logo.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstac <- stack(system.file(\"ex/logo.tif\", package=\"terra\")) #This is a raster stack\nrst <- rast(stac) #now this is a SpatRaster\n```\n:::\n\n\nIts that simple. And to change this back to a `Raster` object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstac <- raster(rst) #now this is a RasterStack\n```\n:::\n\n\n## 9. Options to allow the processing of large files\n\nTerra has some settable options that can help to improve performance. Have a look through them with `?terraOptions`\n\nParticularly useful options include `tempdir`, which provides a default location for files to be written. This can help prevent your C drive being clogged with temp files.\n\nAlso handy is `memfrac`, which lets us stipulate how much RAM `terra` is can use - from 0-0.9.\n\nCheck the current options with `terraOptions()`\n\nSet options using `terraOptions(memfrac=0.2, tempdir = \"C:/temp/terrafiles\")`.\n\n## 10. A real world example with drone data\n\nIn this example, we will use some of my drone data collected from savanna woodlands in north Australia.This is a typical example where we have an orthomosaic, which was derived from a camera (RGB), and a canopy height model, which was derived from LiDAR point cloud.\n\nFirst, we need to reduce the size of the orthomosaic (1.3+ GB is too big). But in reality, we might want that much resolution depending on what we are trying to do.\n\nYou don't need to run the below code, but this is what I did to reduce down the large orthomosaic.\n\n\n::: {.cell}\n\n```{.r .cell-code}\northopath <- \".../hacky_sac/2022-02-23 Basic raster analysis with R/plot1_ortho.tif\"\northo_reduced_path <- \"...2022-02-23 Basic raster analysis with R/plot1_ortho_reduced.tif\"\northo <- rast(orthopath)\nres(ortho) #check the resolution \n\n#now lets reduce it down with aggregate \n\n#note the filename variable lets us write directly to file\naggregate(ortho, fact = 10, fun = 'mean', filename = ortho_reduced_path)\northo_reduced <- rast(ortho_reduced_path)\nres(ortho_reduced)\n```\n:::\n\n\nDownload the reduced orthomosaic [here](https://drive.google.com/file/d/1k0xW1VQS3QE41hm200vJUC2SbMbf6RGs/view?usp=sharing)\n\nAnd the chm [here](https://drive.google.com/file/d/1qoKeXKwTy0ohMQZWfweW4TAj4WV22g05/view?usp=sharing)\n\nThe first thing to do is load the .tifs as `SpatRasters` in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhomefolder <- \"..../Downloads\" #where did you download the files to?\nchm_path <- paste0(homefolder, \"/\", \"plot1_chm.tif\")\northo_path <- paste0(homefolder, \"/\", \"plot1_ortho_reduced.tif\")\n\n#now read in the files using terra\nchm <- rast(chm_path)\northo <- rast(ortho_path)\n```\n:::\n\n\nThis is an example of needing to merge rasters with different geometries into a single raster. Before we can do this, we need to make sure the crs, resolution, origin and extent match.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#do the crs match?\ncrs(chm) == crs(ortho)\n#do the origins match?\norigin(chm) == origin(ortho)\n#do the resolutions match?\nres(chm) == res(ortho)\n#do the extents match?\next(chm) == ext(ortho)\n```\n:::\n\n\nWe should see that the CRS matches, but nothing else.\n\nThe `resample()` function can match the geometries. If we wanted to keep the higher resolution of the orthomosaic, we can run:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchm_resampled <- resample(chm, ortho, method = \"bilinear\")\n#now, geometry should match\nres(chm_resampled) == res(ortho)\norigin(chm_resampled) == origin(ortho)\next(chm_resampled) == ext(ortho)\n```\n:::\n\n\nOn the right track. lets plot them to have a look.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(chm_resampled)\n```\n:::\n\n\n![](images/chm_nottrimmed.PNG)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(ortho)\n```\n:::\n\n\n![](images/ortho_notcropped.PNG)\n\nWe can see that even though they have the same extent - as enforced by the `resample()` - there are a lot of blank cells around the CHM.\n\nLets get rid of those blank (NA) cells using the `trim()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchm_resampled <- trim(chm_resampled)\nplot(chm_resampled)\n```\n:::\n\n\n![](images/chm_resampled.PNG)\n\nThat's better, now lets crop the orthomosaic using the CHM.\n\n\n::: {.cell}\n\n```{.r .cell-code}\northo_cropped <- crop(ortho, chm_resampled)\n```\n:::\n\n\nNow everything should match, and we can finally combine these layers into a single `SpatRaster` object. For this, you can simply concatenate the layers: c(layer1, layer2, layer3).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined <- c(ortho_cropped, chm_resampled)\nplot(combined)\n```\n:::\n\n\n![](images/combined_1.PNG)\n\nThe band names don't make a lot of sense at this point, so we can rename them using the `names()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(combined) <- c('red', 'green', 'blue', 'chm')\n```\n:::\n\n\nFinally, prior to doing some analysis, we might want to stretch the chm to 8bit - so its not under-weighted compared to the RGB data. This calls for the `stretch()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined$chm <- stretch(combined$chm)\nplot(combined)\n```\n:::\n\n\n![](images/combined_final.PNG)\n\nNow we have a raster stack we can work with!\n\n## 11. A fun new package called Layer\n\nOne fun little package I stumbled on recently is called [`layer`](https://github.com/cran/layer). It doesn't really serve a purpose in terms of analysis, although I'll use it to make figures that demonstrate the raster data-sets used in analysis.\n\n<img src=\"https://raw.githubusercontent.com/cran/layer/8af3637e9b6dbe0b936dbac0318797991a4e9371/man/figures/logo.svg\" width=\"250\"/>\n\nUnfortunately, `Layer` calls for `Raster` data, but as we know, it's easy to convert `Raster` to `SpatRaster` objects.\n\nBut before we get into that, lets further reduce the resolution of the `combined` `SpatRaster`, as there is a lot going on in the background of `Layer` and its pretty slow.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined_lowres <- aggregate(combined, fact = 10) #10x less rows and columns\n```\n:::\n\n\nNow we can load the `layer` and `raster` packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"layer\")\nlibrary(layer)\n```\n:::\n\n\nNow we can provide the layers to `tilt_map`, then `plot_tilted_map`, to create a nice looking tilted stack that illustrates our data. Note within the `tilt_map` function, we convert the `SpatRaster` to `Raster` with the `raster()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntilt_map_1 <- tilt_map(raster(combined_lowres$red))\ntilt_map_2 <- tilt_map(raster(combined_lowres$green), x_shift = 0, y_shift = 50)\ntilt_map_3 <- tilt_map(raster(combined_lowres$blue), x_shift = 0, y_shift = 100)\ntilt_map_4 <- tilt_map(raster(combined_lowres$chm), x_shift = 0, y_shift = 150)\n\nmap_list <- list(tilt_map_1, tilt_map_2, tilt_map_3, tilt_map_4)\n\nplot_tiltedmaps(map_list, \n                layer = c(\"value\", \"value\", \"value\", \"value\"),\n                palette = c(\"bilbao\", \"mako\", \"rocket\", \"turbo\"),\n                color = \"grey40\")\n```\n:::\n\n\n![](images/layer_output.PNG)\n\n# About the author\n\nMitch is in the final year of a PhD with the Sustainable Minerals Institute, where he surveys savanna trees with drones to inform mine-site restoration. To process and analyse drone data - LiDAR, photogrammetry, multispec - Mitch has been forced to pick up skills in geospatial analysis using R and python.\n\n![](/images/mitch.PNG)\n\n[![Twitter URL](https://img.shields.io/twitter/url/https/twitter.com/bukotsunikki.svg?style=social&label=Follow%20%2540mitchrudge)](https://twitter.com/mitchrudge)\n\n**Email** mitchel.rudge\\@uq.edu.au\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}